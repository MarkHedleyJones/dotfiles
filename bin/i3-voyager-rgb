#!/usr/bin/env python3
"""
Lightweight version of i3 workspace RGB monitor for Voyager keyboard.
Uses i3-msg instead of i3ipc library - no extra dependencies needed.
"""

import json
import subprocess
import time
import grpc
import sys
import signal
import threading
import os
from pathlib import Path

# Add the lib directory to path to import keymapp modules
# Resolve the real path of the script (follows symlinks)
real_script_path = Path(os.path.realpath(__file__))
dotfiles_dir = real_script_path.parent.parent  # Go up from bin to dotfiles
lib_dir = dotfiles_dir / 'lib'

sys.path.insert(0, str(lib_dir))

try:
    import keymapp_pb2
    import keymapp_pb2_grpc
except ImportError as e:
    print("Error: Cannot import keymapp modules")
    print("Please install grpcio using ONE of these methods:")
    print("  1. System package: sudo apt install python3-grpcio")
    print("  2. With pipx: pipx install grpcio")
    print("  3. In a venv: python3 -m venv venv && venv/bin/pip install grpcio")
    print(f"\nDetails: {e}")
    sys.exit(1)

# Color definitions for workspace states (R, G, B values 0-255)
COLORS = {
    'empty': (0, 0, 0),          # Off/black for empty workspaces
    'occupied': (0, 128, 0),     # Dim blue for workspaces with windows
    'visible': (0, 50, 150),      # Green for visible on another monitor
    'focused': (128, 255, 128),   # Bright blue-white for current workspace
    'urgent': (255, 0, 0),        # Red for urgent workspaces
}

# Mapping of workspace numbers to F-key LED indices on Voyager
# These need to be determined by testing - use test-voyager-leds script
# The Voyager has two halves, LEDs may not be sequential for F-keys
WORKSPACE_TO_LED = {
    1: 1,   # LED under F1 position
    2: 2,   # LED under F2 position
    3: 3,   # LED under F3 position
    4: 4,   # LED under F4 position
    5: 5,   # LED under F5 position
    6: 26,  # LED under F6 position
    7: 27,  # LED under F7 position
    8: 28,  # LED under F8 position
    9: 29,  # LED under F9 position
    10: 30, # LED under F10 position
}

class VoyagerRGBControl:
    """Control Voyager RGB via Keymapp API"""

    def __init__(self):
        self.channel = None
        self.stub = None
        self.connected = False
        self.current_leds = {}  # Store current LED states
        self.refresh_thread = None
        self.running = False

    def connect(self):
        """Connect to Keymapp gRPC service"""
        # Try different socket paths that Keymapp might use
        socket_paths = [
            os.path.expanduser('~/.config/.keymapp/keymapp.sock'),
            '/tmp/keymapp.sock',
            os.path.expanduser('~/.keymapp/keymapp.sock'),
        ]

        for socket_path in socket_paths:
            # Debug: print what we're checking
            # print(f"DEBUG: Checking {socket_path}: exists={os.path.exists(socket_path)}")
            if os.path.exists(socket_path):
                try:
                    self.channel = grpc.insecure_channel(f'unix://{socket_path}')
                    self.stub = keymapp_pb2_grpc.KeyboardServiceStub(self.channel)

                    # Test connection with GetStatus
                    status = self.stub.GetStatus(keymapp_pb2.GetStatusRequest())

                    # Check if keyboard is already connected
                    if status.connected_keyboard.friendly_name:
                        self.connected = True
                        print(f"âœ“ Connected to {status.connected_keyboard.friendly_name} via {socket_path}")
                        self.start_refresh_thread()
                        return True

                    # If not connected, try to connect
                    reply = self.stub.ConnectAnyKeyboard(keymapp_pb2.ConnectAnyKeyboardRequest())
                    if reply.success:
                        self.connected = True
                        print(f"âœ“ Connected to Voyager keyboard via {socket_path}")
                        self.start_refresh_thread()
                        return True
                    else:
                        print("âœ— Failed to connect to keyboard")
                        return False

                except grpc.RpcError as e:
                    # print(f"DEBUG: gRPC error: {e}")
                    continue  # Try next socket path
                except Exception as e:
                    # print(f"DEBUG: Exception: {e}")
                    continue  # Try next socket path

        print(f"âœ— Cannot connect to Keymapp (no socket found)")
        print(f"  Checked: {', '.join(socket_paths)}")
        return False

    def start_refresh_thread(self):
        """Start thread to refresh LEDs periodically"""
        def refresh_loop():
            while self.running:
                time.sleep(2)  # Wait 2 seconds between refreshes
                try:
                    # Refresh all active LEDs
                    for led_id, (r, g, b) in self.current_leds.items():
                        if self.stub:
                            request = keymapp_pb2.SetRGBLedRequest(
                                led=led_id,
                                red=r,
                                green=g,
                                blue=b,
                                sustain=0  # No sustain, we refresh regularly
                            )
                            self.stub.SetRGBLed(request)
                except:
                    pass  # Ignore refresh errors

        self.running = True
        self.refresh_thread = threading.Thread(target=refresh_loop, daemon=True)
        self.refresh_thread.start()

    def set_led_color(self, led_index, r, g, b):
        """Set the color of a specific LED"""
        if not self.connected:
            return False

        # Store the LED state
        if r == 0 and g == 0 and b == 0:
            self.current_leds.pop(led_index, None)
        else:
            self.current_leds[led_index] = (r, g, b)

        try:
            request = keymapp_pb2.SetRGBLedRequest(
                led=led_index,
                red=r,
                green=g,
                blue=b,
                sustain=0  # No sustain, refresh thread handles persistence
            )
            reply = self.stub.SetRGBLed(request)
            return reply.success
        except:
            # Silently fail and try to reconnect next time
            self.connected = False
            return False

    def cleanup(self):
        """Clean up and turn off LEDs"""
        self.running = False  # Stop refresh thread

        if self.connected:
            # Turn off only our workspace LEDs
            for led in WORKSPACE_TO_LED.values():
                try:
                    request = keymapp_pb2.SetRGBLedRequest(
                        led=led,
                        red=0,
                        green=0,
                        blue=0,
                        sustain=0
                    )
                    self.stub.SetRGBLed(request)
                except:
                    pass

        if self.channel:
            self.channel.close()

def get_workspace_states():
    """Get current state of all workspaces using i3-msg"""
    try:
        result = subprocess.run(
            ['i3-msg', '-t', 'get_workspaces'],
            capture_output=True,
            text=True,
            check=True
        )
        workspaces = json.loads(result.stdout)

        states = {}

        # Initialize all workspaces as empty
        for num in WORKSPACE_TO_LED.keys():
            states[num] = 'empty'

        # Update based on actual workspace data
        for ws in workspaces:
            try:
                num = int(ws['name'])
                if num in WORKSPACE_TO_LED:
                    if ws['focused']:
                        states[num] = 'focused'
                    elif ws['visible']:
                        states[num] = 'visible'
                    elif ws.get('urgent', False):
                        states[num] = 'urgent'
                    else:
                        states[num] = 'occupied'
            except (ValueError, KeyError):
                continue

        return states
    except Exception as e:
        print(f"Error getting workspace states: {e}")
        return {}

def update_leds(rgb_control, previous_states=None):
    """Update LEDs based on current workspace states"""
    states = get_workspace_states()

    if previous_states is None:
        previous_states = {}

    changed = False
    for workspace_num, state in states.items():
        if workspace_num in WORKSPACE_TO_LED:
            if previous_states.get(workspace_num) != state:
                led = WORKSPACE_TO_LED[workspace_num]
                color = COLORS[state]
                if rgb_control.set_led_color(led, *color):
                    print(f"  Workspace {workspace_num}: {state} â†’ RGB{color}")
                    changed = True

    return states, changed

def monitor_loop(rgb_control):
    """Main monitoring loop using i3-msg subscribe"""
    print("Monitoring i3 workspaces... (Ctrl+C to exit)")

    # Set initial state
    previous_states, _ = update_leds(rgb_control)

    # Subscribe to i3 events
    process = subprocess.Popen(
        ['i3-msg', '-t', 'subscribe', '-m', '["workspace", "window"]'],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )

    try:
        while True:
            line = process.stdout.readline()
            if not line:
                break

            try:
                event = json.loads(line)
                # Check if this is an event that might change workspace state
                if event.get('change') in ['focus', 'init', 'empty', 'urgent', 'new', 'close', 'move']:
                    previous_states, changed = update_leds(rgb_control, previous_states)
                    if changed and not rgb_control.connected:
                        # Try to reconnect if we lost connection
                        rgb_control.connect()
                        update_leds(rgb_control, {})  # Force full update
            except json.JSONDecodeError:
                continue
            except Exception as e:
                print(f"Error processing event: {e}")

    except KeyboardInterrupt:
        print("\nâœ“ Stopping monitor...")
    finally:
        process.terminate()

def signal_handler(signum, frame):
    """Handle shutdown signals"""
    raise KeyboardInterrupt

def main():
    """Main entry point"""
    print("=" * 50)
    print("i3 Workspace â†’ Voyager RGB Monitor (Lite)")
    print("=" * 50)

    # Set up signal handlers
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # Check dependencies
    try:
        subprocess.run(['i3-msg', '--version'],
                      capture_output=True, check=True)
    except:
        print("âœ— Error: i3-msg not found. Is i3 installed?")
        return 1

    try:
        # Check for both 'Keymapp' and 'keymapp' (case variations)
        result = subprocess.run(['pgrep', '-fi', 'keymapp'],
                              capture_output=True, check=True)
        if result.returncode == 0:
            print("âœ“ Keymapp is running")
    except:
        print("âš  Warning: Keymapp doesn't appear to be running")
        print("  Please start Keymapp for LED control to work")
        print()

    # Initialize RGB control
    rgb_control = VoyagerRGBControl()
    if not rgb_control.connect():
        print("\nâœ— Failed to connect to Keymapp")
        print("  Please ensure:")
        print("  1. Keymapp is running")
        print("  2. Your Voyager keyboard is connected")
        print("  3. You're in the speech-to-text venv (if needed)")
        return 1

    print()
    print("LED Mapping:")
    print("  Workspace 1-10 â†’ F1-F10 keys")
    print("\nColors:")
    print("  âš« Empty     = Off")
    print("  ðŸ”µ Occupied  = Blue")
    print("  ðŸŸ¢ Visible   = Green")
    print("  âšª Focused   = White")
    print("  ðŸ”´ Urgent    = Red")
    print()

    try:
        monitor_loop(rgb_control)
    finally:
        rgb_control.cleanup()
        print("âœ“ LEDs cleared")

    return 0

if __name__ == "__main__":
    sys.exit(main())
