#!/usr/bin/env python3
"""
Lightweight version of i3 workspace RGB monitor for Voyager keyboard.
Uses i3-msg instead of i3ipc library - no extra dependencies needed.
"""

import argparse
import json
import os
import signal
import subprocess
import sys
import threading
import time
from pathlib import Path

import grpc

# Global verbose flag
VERBOSE = False


def log(message, always=False):
    """Print message only if verbose mode is enabled or always=True"""
    if VERBOSE or always:
        print(message)


# Add the lib directory to path to import keymapp modules
# Resolve the real path of the script (follows symlinks)
real_script_path = Path(os.path.realpath(__file__))
dotfiles_dir = real_script_path.parent.parent  # Go up from bin to dotfiles
lib_dir = dotfiles_dir / "lib"

sys.path.insert(0, str(lib_dir))

try:
    import keymapp_pb2
    import keymapp_pb2_grpc
except ImportError as e:
    print("Error: Cannot import keymapp modules")
    print("Please install grpcio using ONE of these methods:")
    print("  1. System package: sudo apt install python3-grpcio")
    print("  2. With pipx: pipx install grpcio")
    print("  3. In a venv: python3 -m venv venv && venv/bin/pip install grpcio")
    print(f"\nDetails: {e}")
    sys.exit(1)


# Load color definitions from keyboard-led-colours.json
def load_color_palette():
    """Load calibrated colors from keyboard-led-colours.json"""
    import json
    from pathlib import Path

    colors_file = Path.home() / ".config" / "keyboard" / "keyboard-led-colours.json"
    if colors_file.exists():
        try:
            with open(colors_file, "r") as f:
                return json.load(f)
        except Exception as e:
            log(
                f"⚠ Warning: Could not load keyboard-led-colours.json: {e}", always=True
            )

    # Return default colors if file not found
    log("⚠ Warning: keyboard-led-colours.json not found, using defaults", always=True)
    return {
        "off": [0, 0, 0],
        "white": [110, 110, 110],
        "white_dim": [30, 30, 30],
        "white_bright": [255, 255, 255],
        "red": [70, 0, 0],
        "red_dim": [30, 0, 0],
        "red_bright": [255, 0, 0],
        "green": [0, 110, 0],
        "green_dim": [0, 30, 0],
        "green_bright": [0, 255, 0],
        "blue": [0, 0, 110],
        "blue_dim": [0, 0, 30],
        "blue_bright": [0, 0, 255],
        "yellow": [110, 110, 0],
        "yellow_dim": [30, 30, 0],
        "yellow_bright": [255, 255, 0],
    }


# Load color palette (made mutable for reloading)
COLOR_PALETTE = load_color_palette()

# Define workspace state to color name mapping
# Using color names as strings that reference the palette
STATE_COLOR_MAP = {
    "empty": "off",  # No color (no windows)
    "occupied": "white",  # Normal white
    "ai-ready": "green",  # Green for AI ready
    "ai-busy": "yellow",  # Yellow for AI busy
    "task-running": "yellow",  # Yellow/amber for running task
    "task-complete": "blue",  # Blue for completed task
    "task-failed": "red",  # Red for failed task
    "urgent": "red",  # Red for urgent
}


# Get RGB values from color names
def get_color_rgb(color_name, brightness="normal"):
    """Get RGB values for a color name with brightness level"""
    if brightness == "dim":
        key = f"{color_name}_dim"
    elif brightness == "bright":
        key = f"{color_name}_bright"
    else:
        key = color_name

    # Special case for "off"
    if color_name == "off":
        return [0, 0, 0]

    # Get color from palette, with fallback
    if key in COLOR_PALETTE:
        return COLOR_PALETTE[key]
    elif color_name in COLOR_PALETTE:
        return COLOR_PALETTE[color_name]
    else:
        return [0, 0, 0]  # Default to off if color not found


# Build color lookup for all states (made mutable for reloading)
COLORS = {}


def rebuild_colors():
    """Rebuild the COLORS dictionary from the current COLOR_PALETTE"""
    global COLORS
    COLORS = {}

    # For each state, create unfocused (dim) and focused (bright) versions
    for state, color_name in STATE_COLOR_MAP.items():
        # Unfocused = dim version
        rgb_dim = get_color_rgb(color_name, "dim")
        COLORS[state] = tuple(rgb_dim)

        # Focused = bright version
        rgb_bright = get_color_rgb(color_name, "bright")
        COLORS[f"{state}_focused"] = tuple(rgb_bright)

    log(f"✓ Rebuilt color mappings from {len(COLOR_PALETTE)} colors")


def reload_color_palette():
    """Reload the color palette from disk and rebuild color mappings"""
    global COLOR_PALETTE
    COLOR_PALETTE = load_color_palette()
    rebuild_colors()
    log(
        f"✓ Reloaded {len(COLOR_PALETTE)} colors from keyboard-led-colours.json",
        always=True,
    )


# Initial build of colors
rebuild_colors()

# Mapping of workspace numbers to F-key LED indices on Voyager
# These need to be determined by testing - use test-voyager-leds script
# The Voyager has two halves, LEDs may not be sequential for F-keys
WORKSPACE_TO_LED = {
    1: 1,  # LED under F1 position
    2: 2,  # LED under F2 position
    3: 3,  # LED under F3 position
    4: 4,  # LED under F4 position
    5: 5,  # LED under F5 position
    6: 26,  # LED under F6 position
    7: 27,  # LED under F7 position
    8: 28,  # LED under F8 position
    9: 29,  # LED under F9 position
    10: 30,  # LED under F10 position
}


class VoyagerRGBControl:
    """Control Voyager RGB via Keymapp API"""

    def __init__(self):
        self.channel = None
        self.stub = None
        self.connected = False
        self.current_leds = {}  # Store current LED states
        self.refresh_thread = None
        self.running = False

    def connect(self):
        """Connect to Keymapp gRPC service"""
        # Try different socket paths that Keymapp might use
        socket_paths = [
            os.path.expanduser("~/.config/.keymapp/keymapp.sock"),
            "/tmp/keymapp.sock",
            os.path.expanduser("~/.keymapp/keymapp.sock"),
        ]

        for socket_path in socket_paths:
            # Debug: print what we're checking
            # print(f"DEBUG: Checking {socket_path}: exists={os.path.exists(socket_path)}")
            if os.path.exists(socket_path):
                try:
                    self.channel = grpc.insecure_channel(f"unix://{socket_path}")
                    self.stub = keymapp_pb2_grpc.KeyboardServiceStub(self.channel)

                    # Test connection with GetStatus
                    status = self.stub.GetStatus(keymapp_pb2.GetStatusRequest())

                    # Check if keyboard is already connected
                    if status.connected_keyboard.friendly_name:
                        self.connected = True
                        log(
                            f"✓ Connected to {status.connected_keyboard.friendly_name} via {socket_path}"
                        )
                        self.start_refresh_thread()
                        return True

                    # If not connected, try to connect
                    reply = self.stub.ConnectAnyKeyboard(
                        keymapp_pb2.ConnectAnyKeyboardRequest()
                    )
                    if reply.success:
                        self.connected = True
                        log(f"✓ Connected to Voyager keyboard via {socket_path}")
                        self.start_refresh_thread()
                        return True
                    else:
                        log("✗ Failed to connect to keyboard", always=True)
                        return False

                except grpc.RpcError as e:
                    # print(f"DEBUG: gRPC error: {e}")
                    continue  # Try next socket path
                except Exception as e:
                    # print(f"DEBUG: Exception: {e}")
                    continue  # Try next socket path

        log(f"✗ Cannot connect to Keymapp (no socket found)", always=True)
        log(f"  Checked: {', '.join(socket_paths)}", always=True)
        return False

    def start_refresh_thread(self):
        """Start thread to refresh LEDs periodically"""

        def refresh_loop():
            while self.running:
                time.sleep(2)  # Wait 2 seconds between refreshes
                try:
                    # Refresh all active LEDs
                    for led_id, (r, g, b) in self.current_leds.items():
                        if self.stub:
                            request = keymapp_pb2.SetRGBLedRequest(
                                led=led_id,
                                red=r,
                                green=g,
                                blue=b,
                                sustain=0,  # No sustain, we refresh regularly
                            )
                            self.stub.SetRGBLed(request)
                except:
                    pass  # Ignore refresh errors

        self.running = True
        self.refresh_thread = threading.Thread(target=refresh_loop, daemon=True)
        self.refresh_thread.start()

    def set_led_color(self, led_index, r, g, b):
        """Set the color of a specific LED"""
        if not self.connected:
            return False

        # Store the LED state
        if r == 0 and g == 0 and b == 0:
            self.current_leds.pop(led_index, None)
        else:
            self.current_leds[led_index] = (r, g, b)

        try:
            request = keymapp_pb2.SetRGBLedRequest(
                led=led_index,
                red=r,
                green=g,
                blue=b,
                sustain=0,  # No sustain, refresh thread handles persistence
            )
            reply = self.stub.SetRGBLed(request)
            return reply.success
        except:
            # Silently fail and try to reconnect next time
            self.connected = False
            return False

    def cleanup(self):
        """Clean up and turn off LEDs"""
        self.running = False  # Stop refresh thread

        if self.connected:
            # Turn off only our workspace LEDs
            for led in WORKSPACE_TO_LED.values():
                try:
                    request = keymapp_pb2.SetRGBLedRequest(
                        led=led, red=0, green=0, blue=0, sustain=0
                    )
                    self.stub.SetRGBLed(request)
                except:
                    pass

        if self.channel:
            self.channel.close()


# Priority order for states (highest priority first)
STATE_PRIORITY = [
    "urgent",
    "task-failed",
    "ai-busy",
    "task-running",
    "task-complete",
    "ai-ready",
    "occupied",
    "empty",
]


def resolve_state_priority(state):
    """Resolve the priority of a state for display purposes"""
    try:
        return STATE_PRIORITY.index(state)
    except ValueError:
        return 999  # Unknown states get lowest priority


def get_workspace_states_from_file():
    """Get workspace states from the status file"""
    states = {}
    status_file = Path.home() / ".config" / "i3" / "workspace-status.json"

    if status_file.exists():
        try:
            with open(status_file, "r") as f:
                data = json.load(f)
                for ws in range(1, 11):
                    ws_str = str(ws)
                    if ws_str in data:
                        ws_data = data[ws_str]

                        # Handle both array format and legacy string format
                        if isinstance(ws_data, list):
                            # New array format - pick highest priority state
                            if ws_data:
                                # Convert any legacy claude-* states
                                ws_data = [
                                    (
                                        "ai-ready"
                                        if s == "claude-ready"
                                        else "ai-busy" if s == "claude-busy" else s
                                    )
                                    for s in ws_data
                                ]

                                # Pick the highest priority state
                                best_state = min(
                                    ws_data, key=lambda s: resolve_state_priority(s)
                                )
                                states[ws] = best_state
                            else:
                                states[ws] = "empty"
                        else:
                            # Legacy string format
                            status = ws_data
                            if status == "claude-ready":
                                status = "ai-ready"
                            elif status == "claude-busy":
                                status = "ai-busy"

                            if status:
                                states[ws] = status
                            else:
                                states[ws] = "empty"
                    else:
                        states[ws] = "empty"
        except Exception:
            pass  # Ignore errors reading status

    # Initialize missing workspaces as empty
    for ws in range(1, 11):
        if ws not in states:
            states[ws] = "empty"

    return states


def update_workspace_state_file(workspace_states):
    """Update the workspace status file with current states (as arrays)"""
    status_file = Path.home() / ".config" / "i3" / "workspace-status.json"

    try:
        # Ensure directory exists
        status_file.parent.mkdir(parents=True, exist_ok=True)

        # Read existing data to preserve array states
        existing_data = {}
        if status_file.exists():
            try:
                with open(status_file, "r") as f:
                    existing_data = json.load(f)
            except:
                pass

        # Build new data structure
        data = {}
        for ws in range(1, 11):
            ws_str = str(ws)

            # Get existing array of states for this workspace
            existing_states = existing_data.get(ws_str, [])
            if not isinstance(existing_states, list):
                # Convert legacy string to array
                existing_states = [existing_states] if existing_states else []

            # Get the new base state (empty/occupied/urgent)
            new_base_state = workspace_states.get(ws, "empty")

            # Filter out old base states, keep special states (ai-*, task-*)
            preserved_states = [
                s
                for s in existing_states
                if s
                in [
                    "ai-ready",
                    "ai-busy",
                    "task-running",
                    "task-complete",
                    "task-failed",
                ]
            ]

            # Build final state array
            if new_base_state == "empty":
                # Empty workspace clears all states
                data[ws_str] = ["empty"]
            else:
                # Combine base state with preserved special states
                states_set = set([new_base_state] + preserved_states)
                # Remove redundant "occupied" if we have special states
                if len(states_set) > 1 and "occupied" in states_set:
                    states_set.remove("occupied")
                data[ws_str] = list(states_set)

        with open(status_file, "w") as f:
            json.dump(data, f, indent=2)

        return True

    except Exception as e:
        log(f"Error updating workspace status file: {e}", always=True)
        return False


def update_focused_workspace(workspace_num):
    """Update the focused state in the file - add to new workspace, remove from others
    Also removes task-complete and task-failed from the newly focused workspace"""
    status_file = Path.home() / ".config" / "i3" / "workspace-status.json"

    try:
        # Ensure directory exists
        status_file.parent.mkdir(parents=True, exist_ok=True)

        # Read existing data
        data = {}
        if status_file.exists():
            with open(status_file, "r") as f:
                data = json.load(f)

        # Ensure all workspaces exist as arrays
        for ws in range(1, 11):
            ws_str = str(ws)
            if ws_str not in data:
                data[ws_str] = ["empty"]
            elif not isinstance(data[ws_str], list):
                # Convert legacy format
                data[ws_str] = [data[ws_str]] if data[ws_str] else ["empty"]

        # Remove "focused" from all workspaces
        for ws_str in data:
            if isinstance(data[ws_str], list) and "focused" in data[ws_str]:
                data[ws_str].remove("focused")

        # Handle the newly focused workspace
        if workspace_num and 1 <= workspace_num <= 10:
            ws_str = str(workspace_num)

            # Remove completed task states from the newly focused workspace
            task_states_to_clear = ["task-complete", "task-failed"]
            cleared_states = []
            for task_state in task_states_to_clear:
                if task_state in data[ws_str]:
                    data[ws_str].remove(task_state)
                    cleared_states.append(task_state)

            # Add "focused" to this workspace
            if "focused" not in data[ws_str]:
                data[ws_str].append("focused")

            # Ensure we don't have an empty array
            if not data[ws_str]:
                data[ws_str] = ["occupied"]

            log(f"  → Focus moved to workspace {workspace_num}")
            if cleared_states:
                log(
                    f"  ✓ Cleared {', '.join(cleared_states)} from workspace {workspace_num}"
                )

        # Write back
        with open(status_file, "w") as f:
            json.dump(data, f, indent=2)

        return True

    except Exception as e:
        log(f"Error updating focused workspace: {e}", always=True)
        return False


def remove_task_states_from_workspace(workspace_num):
    """Remove all task-related states from a workspace when it gets focus"""
    status_file = Path.home() / ".config" / "i3" / "workspace-status.json"

    try:
        if status_file.exists():
            with open(status_file, "r") as f:
                data = json.load(f)

            ws_str = str(workspace_num)
            if ws_str in data:
                states = data[ws_str]

                # Handle array format
                if isinstance(states, list):
                    # Remove only completed task states (not task-running since it's still active)
                    task_states = ["task-complete", "task-failed"]
                    removed_states = []

                    for task_state in task_states:
                        if task_state in states:
                            states.remove(task_state)
                            removed_states.append(task_state)

                    if removed_states:
                        # Ensure we don't have an empty array
                        if not states:
                            states = ["occupied"]
                        data[ws_str] = states

                        with open(status_file, "w") as f:
                            json.dump(data, f, indent=2)

                        log(
                            f"  ✓ Cleared {', '.join(removed_states)} from workspace {workspace_num}"
                        )
                        return True
    except Exception as e:
        log(f"Error removing task states: {e}", always=True)

    return False


def sync_workspace_states_to_file():
    """Sync i3 workspace state to the status file"""
    try:
        # Get i3 tree to find which workspaces have windows
        result = subprocess.run(
            ["i3-msg", "-t", "get_tree"],
            capture_output=True,
            text=True,
            check=True,
        )
        tree = json.loads(result.stdout)

        # Get urgent workspaces
        ws_result = subprocess.run(
            ["i3-msg", "-t", "get_workspaces"],
            capture_output=True,
            text=True,
            check=True,
        )
        workspace_info = json.loads(ws_result.stdout)
        urgent_workspaces = {
            int(ws["name"]): True
            for ws in workspace_info
            if ws.get("urgent", False) and ws["name"].isdigit()
        }

        # Find which workspaces have windows
        workspaces_with_windows = set()

        def find_workspaces(node):
            """Recursively find workspaces with windows"""
            if node.get("type") == "workspace" and node.get("name"):
                try:
                    ws_num = int(node["name"])
                    if has_windows(node):
                        workspaces_with_windows.add(ws_num)
                except (ValueError, KeyError):
                    pass

            for child in node.get("nodes", []) + node.get("floating_nodes", []):
                find_workspaces(child)

        def has_windows(node):
            """Check if a node or its children have actual windows"""
            if node.get("window"):
                return True

            for child in node.get("nodes", []) + node.get("floating_nodes", []):
                if has_windows(child):
                    return True

            return False

        find_workspaces(tree)

        # Read current states from file
        current_states = get_workspace_states_from_file()

        # Build new states
        new_states = {}
        for ws in range(1, 11):
            if ws in urgent_workspaces:
                new_states[ws] = "urgent"
            elif ws in workspaces_with_windows:
                # Preserve AI and task states if they exist
                current = current_states.get(ws, "occupied")
                if current in [
                    "ai-ready",
                    "ai-busy",
                    "task-running",
                    "task-complete",
                    "task-failed",
                ]:
                    new_states[ws] = current
                else:
                    new_states[ws] = "occupied"
            else:
                # Workspace is empty
                new_states[ws] = "empty"

        # Write updated states to file
        update_workspace_state_file(new_states)

        return new_states

    except Exception as e:
        log(f"Error syncing workspace states: {e}", always=True)
        return {}


def get_workspace_states():
    """Get current state of all workspaces from file only"""
    try:
        # Get states from file (which now includes focused state)
        file_states = get_workspace_states_from_file()

        # Build states with focus information from the file
        states = {}
        status_file = Path.home() / ".config" / "i3" / "workspace-status.json"

        if status_file.exists():
            with open(status_file, "r") as f:
                data = json.load(f)

                for num in WORKSPACE_TO_LED.keys():
                    ws_str = str(num)
                    ws_data = data.get(ws_str, ["empty"])

                    # Ensure it's a list
                    if not isinstance(ws_data, list):
                        ws_data = [ws_data] if ws_data else ["empty"]

                    # Check if this workspace is focused
                    is_focused = "focused" in ws_data

                    # Get the display state (not including "focused")
                    display_states = [s for s in ws_data if s != "focused"]
                    if display_states:
                        # Pick highest priority state (excluding focused)
                        best_state = min(
                            display_states, key=lambda s: resolve_state_priority(s)
                        )
                    else:
                        best_state = "empty"

                    states[num] = (best_state, is_focused)
        else:
            # No file, all empty and unfocused
            for num in WORKSPACE_TO_LED.keys():
                states[num] = ("empty", False)

        return states
    except Exception as e:
        log(f"Error getting workspace states: {e}", always=True)
        return {}


def update_leds(rgb_control, previous_states=None):
    """Update LEDs based on current workspace states"""
    states = get_workspace_states()

    if previous_states is None:
        previous_states = {}

    changed = False
    for workspace_num, (base_state, is_focused) in states.items():
        if workspace_num in WORKSPACE_TO_LED:
            # Create state key with focus suffix
            state_key = f"{base_state}_focused" if is_focused else base_state

            if previous_states.get(workspace_num) != (base_state, is_focused):
                led = WORKSPACE_TO_LED[workspace_num]
                color = COLORS[state_key]
                if rgb_control.set_led_color(led, *color):
                    circle = get_color_circle(*color)
                    focus_indicator = " [FOCUSED]" if is_focused else ""
                    log(
                        f"  {circle} Workspace {workspace_num}: {base_state}{focus_indicator} → RGB{color}"
                    )
                    changed = True

    return states, changed


def get_color_circle(r, g, b):
    """Get appropriate colored circle emoji based on RGB values"""
    # Convert to 0-1 range for analysis
    r_norm, g_norm, b_norm = r / 255, g / 255, b / 255

    # Black/Off
    if r < 10 and g < 10 and b < 10:
        return "⚫"

    # White (all high values)
    if r > 200 and g > 200 and b > 200:
        return "⚪"

    # Red dominant
    if r_norm > max(g_norm, b_norm) * 1.5 and r > 100:
        return "🔴"

    # Green dominant
    if g_norm > max(r_norm, b_norm) * 1.5 and g > 100:
        return "🟢"

    # Blue dominant
    if b_norm > max(r_norm, g_norm) * 1.5 and b > 100:
        return "🔵"

    # Yellow (red + green)
    if r > 150 and g > 150 and b < 100:
        return "🟡"

    # Purple/Magenta (red + blue)
    if r > 150 and b > 150 and g < 100:
        return "🟣"

    # Orange (more red than green, low blue)
    if r > 200 and g > 100 and g < 200 and b < 100:
        return "🟠"

    # Brown (dark orange/yellow)
    if 50 < r < 150 and 25 < g < 100 and b < 50:
        return "🟤"

    # Default to gray for mixed/unclear colors
    return "⚪"


def monitor_loop(rgb_control):
    """Main monitoring loop using i3-msg subscribe and inotify file monitoring"""
    log("Monitoring i3 workspaces and keyboard colors... (Ctrl+C to exit)")

    # Sync initial workspace states to file
    sync_workspace_states_to_file()

    # Get initial focus and update in file
    try:
        result = subprocess.run(
            ["i3-msg", "-t", "get_workspaces"],
            capture_output=True,
            text=True,
            check=True,
        )
        workspaces = json.loads(result.stdout)
        for ws in workspaces:
            if ws.get("focused"):
                try:
                    ws_num = int(ws["name"])
                    update_focused_workspace(ws_num)
                    break
                except (ValueError, KeyError):
                    pass
    except Exception as e:
        log(f"Error getting initial focus: {e}", always=True)

    # Set initial state
    previous_states, _ = update_leds(rgb_control)

    # Set up file watching for workspace status file
    status_file = Path.home() / ".config" / "i3" / "workspace-status.json"

    # Set up file watching for keyboard colors file
    # Follow symlink to watch the actual file location
    colors_file = Path.home() / ".config" / "keyboard" / "keyboard-led-colours.json"
    if colors_file.is_symlink():
        colors_file = Path(os.path.realpath(colors_file))
        log(f"Following symlink to actual colors file: {colors_file}")

    # Start inotify processes to watch both files
    inotify_processes = []

    # Watch Claude status file
    if status_file.exists():
        # Use inotifywait to monitor the specific file for modifications
        # Watch the directory for moves and the file for modifications
        status_inotify = subprocess.Popen(
            [
                "inotifywait",
                "-m",
                "-e",
                "modify,moved_to",
                str(status_file.parent),  # Watch the directory
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
        )
        inotify_processes.append((status_inotify, "workspace-status.json"))
        log(f"Watching {status_file} for changes")

    # Watch keyboard colors file
    if colors_file.exists():
        colors_inotify = subprocess.Popen(
            [
                "inotifywait",
                "-m",
                "-e",
                "modify,moved_to",
                str(colors_file.parent),  # Watch the directory
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
        )
        inotify_processes.append((colors_inotify, "keyboard-led-colours.json"))
        log(f"Watching {colors_file} for changes")

    # Subscribe to i3 events
    i3_process = subprocess.Popen(
        ["i3-msg", "-t", "subscribe", "-m", '["workspace", "window"]'],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )

    try:
        # Use select to monitor both i3 events and file changes
        import select

        while True:
            # Build list of file descriptors to monitor
            fds = [i3_process.stdout]
            for proc, _ in inotify_processes:
                if proc and proc.poll() is None:
                    fds.append(proc.stdout)

            # Wait for events from either source
            readable, _, _ = select.select(fds, [], [], 1.0)

            # Check for i3 events
            if i3_process.stdout in readable:
                line = i3_process.stdout.readline()
                if not line:
                    break

                try:
                    event = json.loads(line)
                    # Check if this is an event that might change workspace state
                    if event.get("change") in [
                        "focus",
                        "init",
                        "empty",
                        "urgent",
                        "new",
                        "close",
                        "move",
                    ]:
                        # Handle focus event to update focused state and clear task states
                        if event.get("change") == "focus":
                            # Get the workspace number that got focus
                            if event.get("current") and event["current"].get("name"):
                                try:
                                    ws_num = int(event["current"]["name"])
                                    # Update focused state and clear completed task states
                                    update_focused_workspace(ws_num)
                                except (ValueError, KeyError):
                                    pass

                        # Sync i3 state to file when workspace state might have changed
                        if event.get("change") in [
                            "init",
                            "empty",
                            "urgent",
                            "new",
                            "close",
                            "move",
                        ]:
                            sync_workspace_states_to_file()

                        previous_states, changed = update_leds(
                            rgb_control, previous_states
                        )
                        if changed and not rgb_control.connected:
                            # Try to reconnect if we lost connection
                            rgb_control.connect()
                            update_leds(rgb_control, {})  # Force full update
                except json.JSONDecodeError:
                    continue
                except Exception as e:
                    log(f"Error processing i3 event: {e}", always=True)

            # Check for file change events from all inotify processes
            for proc, filename in inotify_processes:
                if proc and proc.stdout in readable:
                    event_line = proc.stdout.readline()
                    if event_line and filename in event_line:
                        if filename == "workspace-status.json":
                            log("Workspace status file changed, updating LEDs...")
                            previous_states, changed = update_leds(
                                rgb_control, previous_states
                            )
                            if changed and not rgb_control.connected:
                                rgb_control.connect()
                                update_leds(rgb_control, {})
                        elif filename == "keyboard-led-colours.json":
                            log(
                                "🎨 Keyboard colors file changed, reloading colors...",
                                always=True,
                            )
                            reload_color_palette()
                            # Force full LED update with new colors
                            previous_states = {}  # Clear states to force refresh
                            previous_states, changed = update_leds(
                                rgb_control, previous_states
                            )
                            if changed:
                                log(
                                    "✓ Colors reloaded and LEDs updated successfully!",
                                    always=True,
                                )
                            if not rgb_control.connected:
                                rgb_control.connect()
                                update_leds(rgb_control, {})

    except KeyboardInterrupt:
        log("\n✓ Stopping monitor...")
    finally:
        i3_process.terminate()
        for proc, _ in inotify_processes:
            if proc:
                proc.terminate()


def signal_handler(signum, frame):
    """Handle shutdown signals"""
    raise KeyboardInterrupt


def main():
    """Main entry point"""
    global VERBOSE

    # Parse command line arguments
    parser = argparse.ArgumentParser(description="i3 Workspace RGB Monitor for Voyager")
    parser.add_argument(
        "-v",
        "--verbose",
        action="store_true",
        help="Enable verbose output for debugging",
    )
    args = parser.parse_args()

    VERBOSE = args.verbose

    # Kill any existing instances of this script
    try:
        # Get current process ID
        current_pid = os.getpid()

        # Find all i3-voyager-rgb processes
        result = subprocess.run(
            ["pgrep", "-f", "i3-voyager-rgb"],
            capture_output=True,
            text=True,
            check=False,
        )

        if result.returncode == 0:
            pids = result.stdout.strip().split("\n")
            for pid_str in pids:
                try:
                    pid = int(pid_str)
                    # Don't kill ourselves
                    if pid != current_pid:
                        os.kill(pid, signal.SIGTERM)
                        log(
                            f"✓ Killed existing i3-voyager-rgb process (PID: {pid})",
                            always=True,
                        )
                        # Give it a moment to clean up
                        time.sleep(0.5)
                except (ValueError, ProcessLookupError):
                    pass
    except Exception as e:
        # Silently continue if we can't kill old processes
        pass

    log("=" * 50)
    log("i3 Workspace → Voyager RGB Monitor (Lite)")
    log("=" * 50)

    # Set up signal handlers
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # Check dependencies
    try:
        subprocess.run(["i3-msg", "--version"], capture_output=True, check=True)
    except:
        log("✗ Error: i3-msg not found. Is i3 installed?", always=True)
        return 1

    try:
        # Check for both 'Keymapp' and 'keymapp' (case variations)
        result = subprocess.run(
            ["pgrep", "-fi", "keymapp"], capture_output=True, check=True
        )
        if result.returncode == 0:
            log("✓ Keymapp is running")
    except:
        log("⚠ Warning: Keymapp doesn't appear to be running", always=True)
        log("  Please start Keymapp for LED control to work", always=True)
        log("")

    # Initialize RGB control
    rgb_control = VoyagerRGBControl()
    if not rgb_control.connect():
        log("\n✗ Failed to connect to Keymapp", always=True)
        log("  Please ensure:", always=True)
        log("  1. Keymapp is running", always=True)
        log("  2. Your Voyager keyboard is connected", always=True)
        log("  3. You're in the speech-to-text venv (if needed)", always=True)
        return 1

    log("")
    log("LED Mapping:")
    log("  Workspace 1-10 → F1-F10 keys")
    log("\nColor Mappings (from keyboard-led-colours.json):")
    log("")

    # Show color mappings
    for base_state, color_name in STATE_COLOR_MAP.items():
        # Format state display name
        if base_state == "claude_ready":
            state_display = "Claude Ready"
        elif base_state == "claude_busy":
            state_display = "Claude Busy"
        else:
            state_display = base_state.capitalize()

        # Show unfocused version
        unfocused_key = base_state
        unfocused_actual = COLORS[unfocused_key]
        unfocused_circle = get_color_circle(*unfocused_actual)

        # Show focused version
        focused_key = f"{base_state}_focused"
        focused_actual = COLORS[focused_key]
        focused_circle = get_color_circle(*focused_actual)

        state_display = state_display.ljust(12)

        # Print both unfocused and focused versions with color names
        log(
            f"  {unfocused_circle} {state_display} unfocused: {color_name}_dim → RGB{unfocused_actual}"
        )
        log(
            f"  {focused_circle} {state_display} focused:   {color_name}_bright → RGB{focused_actual}"
        )

    log("")

    try:
        monitor_loop(rgb_control)
    finally:
        rgb_control.cleanup()
        log("✓ LEDs cleared")

    return 0


if __name__ == "__main__":
    sys.exit(main())
