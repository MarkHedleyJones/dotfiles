#!/usr/bin/env python3
"""
Lightweight version of i3 workspace RGB monitor for Voyager keyboard.
Uses i3-msg instead of i3ipc library - no extra dependencies needed.
"""

import argparse
import json
import os
import signal
import subprocess
import sys
import threading
import time
from pathlib import Path

import grpc

# Global verbose flag
VERBOSE = False

def log(message, always=False):
    """Print message only if verbose mode is enabled or always=True"""
    if VERBOSE or always:
        print(message)

# Add the lib directory to path to import keymapp modules
# Resolve the real path of the script (follows symlinks)
real_script_path = Path(os.path.realpath(__file__))
dotfiles_dir = real_script_path.parent.parent  # Go up from bin to dotfiles
lib_dir = dotfiles_dir / "lib"

sys.path.insert(0, str(lib_dir))

try:
    import keymapp_pb2
    import keymapp_pb2_grpc
except ImportError as e:
    print("Error: Cannot import keymapp modules")
    print("Please install grpcio using ONE of these methods:")
    print("  1. System package: sudo apt install python3-grpcio")
    print("  2. With pipx: pipx install grpcio")
    print("  3. In a venv: python3 -m venv venv && venv/bin/pip install grpcio")
    print(f"\nDetails: {e}")
    sys.exit(1)


# Load color definitions from keyboard-led-colours.json
def load_color_palette():
    """Load calibrated colors from keyboard-led-colours.json"""
    import json
    from pathlib import Path

    colors_file = Path.home() / ".config" / "keyboard" / "keyboard-led-colours.json"
    if colors_file.exists():
        try:
            with open(colors_file, "r") as f:
                return json.load(f)
        except Exception as e:
            log(f"âš  Warning: Could not load keyboard-led-colours.json: {e}", always=True)

    # Return default colors if file not found
    log("âš  Warning: keyboard-led-colours.json not found, using defaults", always=True)
    return {
        "off": [0, 0, 0],
        "white": [110, 110, 110],
        "white_dim": [30, 30, 30],
        "white_bright": [255, 255, 255],
        "red": [70, 0, 0],
        "red_dim": [30, 0, 0],
        "red_bright": [255, 0, 0],
        "green": [0, 110, 0],
        "green_dim": [0, 30, 0],
        "green_bright": [0, 255, 0],
        "blue": [0, 0, 110],
        "blue_dim": [0, 0, 30],
        "blue_bright": [0, 0, 255],
        "yellow": [110, 110, 0],
        "yellow_dim": [30, 30, 0],
        "yellow_bright": [255, 255, 0],
    }


# Load color palette
COLOR_PALETTE = load_color_palette()

# Define workspace state to color name mapping
# Using color names as strings that reference the palette
STATE_COLOR_MAP = {
    "empty": "off",  # No color
    "occupied": "white",  # Normal white
    "claude_ready": "green",  # Green for ready
    "claude_busy": "yellow",  # Yellow for busy
    "visible": "white",  # Blue for visible
    "focused": "white",  # Blue for focused (will use bright)
    "urgent": "red",  # Red for urgent
}


# Get RGB values from color names
def get_color_rgb(color_name, brightness="normal"):
    """Get RGB values for a color name with brightness level"""
    if brightness == "dim":
        key = f"{color_name}_dim"
    elif brightness == "bright":
        key = f"{color_name}_bright"
    else:
        key = color_name

    # Special case for "off"
    if color_name == "off":
        return [0, 0, 0]

    # Get color from palette, with fallback
    if key in COLOR_PALETTE:
        return COLOR_PALETTE[key]
    elif color_name in COLOR_PALETTE:
        return COLOR_PALETTE[color_name]
    else:
        return [0, 0, 0]  # Default to off if color not found


# Build color lookup for all states
COLORS = {}

# For each state, create unfocused (dim) and focused (bright) versions
for state, color_name in STATE_COLOR_MAP.items():
    # Unfocused = dim version
    rgb_dim = get_color_rgb(color_name, "dim")
    COLORS[state] = tuple(rgb_dim)

    # Focused = bright version
    rgb_bright = get_color_rgb(color_name, "bright")
    COLORS[f"{state}_focused"] = tuple(rgb_bright)

log(f"âœ“ Loaded {len(COLOR_PALETTE)} colors from keyboard-led-colours.json")

# Mapping of workspace numbers to F-key LED indices on Voyager
# These need to be determined by testing - use test-voyager-leds script
# The Voyager has two halves, LEDs may not be sequential for F-keys
WORKSPACE_TO_LED = {
    1: 1,  # LED under F1 position
    2: 2,  # LED under F2 position
    3: 3,  # LED under F3 position
    4: 4,  # LED under F4 position
    5: 5,  # LED under F5 position
    6: 26,  # LED under F6 position
    7: 27,  # LED under F7 position
    8: 28,  # LED under F8 position
    9: 29,  # LED under F9 position
    10: 30,  # LED under F10 position
}


class VoyagerRGBControl:
    """Control Voyager RGB via Keymapp API"""

    def __init__(self):
        self.channel = None
        self.stub = None
        self.connected = False
        self.current_leds = {}  # Store current LED states
        self.refresh_thread = None
        self.running = False

    def connect(self):
        """Connect to Keymapp gRPC service"""
        # Try different socket paths that Keymapp might use
        socket_paths = [
            os.path.expanduser("~/.config/.keymapp/keymapp.sock"),
            "/tmp/keymapp.sock",
            os.path.expanduser("~/.keymapp/keymapp.sock"),
        ]

        for socket_path in socket_paths:
            # Debug: print what we're checking
            # print(f"DEBUG: Checking {socket_path}: exists={os.path.exists(socket_path)}")
            if os.path.exists(socket_path):
                try:
                    self.channel = grpc.insecure_channel(f"unix://{socket_path}")
                    self.stub = keymapp_pb2_grpc.KeyboardServiceStub(self.channel)

                    # Test connection with GetStatus
                    status = self.stub.GetStatus(keymapp_pb2.GetStatusRequest())

                    # Check if keyboard is already connected
                    if status.connected_keyboard.friendly_name:
                        self.connected = True
                        log(
                            f"âœ“ Connected to {status.connected_keyboard.friendly_name} via {socket_path}"
                        )
                        self.start_refresh_thread()
                        return True

                    # If not connected, try to connect
                    reply = self.stub.ConnectAnyKeyboard(
                        keymapp_pb2.ConnectAnyKeyboardRequest()
                    )
                    if reply.success:
                        self.connected = True
                        log(f"âœ“ Connected to Voyager keyboard via {socket_path}")
                        self.start_refresh_thread()
                        return True
                    else:
                        log("âœ— Failed to connect to keyboard", always=True)
                        return False

                except grpc.RpcError as e:
                    # print(f"DEBUG: gRPC error: {e}")
                    continue  # Try next socket path
                except Exception as e:
                    # print(f"DEBUG: Exception: {e}")
                    continue  # Try next socket path

        log(f"âœ— Cannot connect to Keymapp (no socket found)", always=True)
        log(f"  Checked: {', '.join(socket_paths)}", always=True)
        return False

    def start_refresh_thread(self):
        """Start thread to refresh LEDs periodically"""

        def refresh_loop():
            while self.running:
                time.sleep(2)  # Wait 2 seconds between refreshes
                try:
                    # Refresh all active LEDs
                    for led_id, (r, g, b) in self.current_leds.items():
                        if self.stub:
                            request = keymapp_pb2.SetRGBLedRequest(
                                led=led_id,
                                red=r,
                                green=g,
                                blue=b,
                                sustain=0,  # No sustain, we refresh regularly
                            )
                            self.stub.SetRGBLed(request)
                except:
                    pass  # Ignore refresh errors

        self.running = True
        self.refresh_thread = threading.Thread(target=refresh_loop, daemon=True)
        self.refresh_thread.start()

    def set_led_color(self, led_index, r, g, b):
        """Set the color of a specific LED"""
        if not self.connected:
            return False

        # Store the LED state
        if r == 0 and g == 0 and b == 0:
            self.current_leds.pop(led_index, None)
        else:
            self.current_leds[led_index] = (r, g, b)

        try:
            request = keymapp_pb2.SetRGBLedRequest(
                led=led_index,
                red=r,
                green=g,
                blue=b,
                sustain=0,  # No sustain, refresh thread handles persistence
            )
            reply = self.stub.SetRGBLed(request)
            return reply.success
        except:
            # Silently fail and try to reconnect next time
            self.connected = False
            return False

    def cleanup(self):
        """Clean up and turn off LEDs"""
        self.running = False  # Stop refresh thread

        if self.connected:
            # Turn off only our workspace LEDs
            for led in WORKSPACE_TO_LED.values():
                try:
                    request = keymapp_pb2.SetRGBLedRequest(
                        led=led, red=0, green=0, blue=0, sustain=0
                    )
                    self.stub.SetRGBLed(request)
                except:
                    pass

        if self.channel:
            self.channel.close()


def get_claude_states():
    """Get Claude status for each workspace"""
    claude_states = {}
    status_file = Path.home() / ".claude" / "workspace-status.json"

    if status_file.exists():
        try:
            with open(status_file, "r") as f:
                data = json.load(f)
                for ws in range(1, 11):
                    ws_str = str(ws)
                    if ws_str in data:
                        status = data[ws_str]
                        if status == "busy":
                            claude_states[ws] = "claude_busy"
                        elif status == "ready":
                            claude_states[ws] = "claude_ready"
                        # Empty string or "idle" means no Claude activity
        except Exception:
            pass  # Ignore errors reading Claude status

    return claude_states


def get_workspace_states():
    """Get current state of all workspaces using i3-msg and Claude status"""
    try:
        result = subprocess.run(
            ["i3-msg", "-t", "get_workspaces"],
            capture_output=True,
            text=True,
            check=True,
        )
        workspaces = json.loads(result.stdout)

        states = {}
        claude_states = get_claude_states()

        # Initialize all workspaces as empty
        for num in WORKSPACE_TO_LED.keys():
            states[num] = ("empty", False)  # (state, is_focused)

        # Update based on actual workspace data
        for ws in workspaces:
            try:
                num = int(ws["name"])
                if num in WORKSPACE_TO_LED:
                    is_focused = ws["focused"]

                    # Priority order for base state: urgent > claude_busy > claude_ready > visible > occupied
                    if ws.get("urgent", False):
                        base_state = "urgent"
                    elif num in claude_states and claude_states[num] == "claude_busy":
                        base_state = "claude_busy"
                    elif num in claude_states and claude_states[num] == "claude_ready":
                        base_state = "claude_ready"
                    elif ws["visible"]:
                        base_state = "visible"  # Visible but not focused
                    else:
                        base_state = "occupied"

                    states[num] = (base_state, is_focused)
            except (ValueError, KeyError):
                continue

        return states
    except Exception as e:
        log(f"Error getting workspace states: {e}", always=True)
        return {}


def update_leds(rgb_control, previous_states=None):
    """Update LEDs based on current workspace states"""
    states = get_workspace_states()

    if previous_states is None:
        previous_states = {}

    changed = False
    for workspace_num, (base_state, is_focused) in states.items():
        if workspace_num in WORKSPACE_TO_LED:
            # Create state key with focus suffix
            state_key = f"{base_state}_focused" if is_focused else base_state

            if previous_states.get(workspace_num) != (base_state, is_focused):
                led = WORKSPACE_TO_LED[workspace_num]
                color = COLORS[state_key]
                if rgb_control.set_led_color(led, *color):
                    circle = get_color_circle(*color)
                    focus_indicator = " [FOCUSED]" if is_focused else ""
                    log(
                        f"  {circle} Workspace {workspace_num}: {base_state}{focus_indicator} â†’ RGB{color}"
                    )
                    changed = True

    return states, changed


def get_color_circle(r, g, b):
    """Get appropriate colored circle emoji based on RGB values"""
    # Convert to 0-1 range for analysis
    r_norm, g_norm, b_norm = r / 255, g / 255, b / 255

    # Black/Off
    if r < 10 and g < 10 and b < 10:
        return "âš«"

    # White (all high values)
    if r > 200 and g > 200 and b > 200:
        return "âšª"

    # Red dominant
    if r_norm > max(g_norm, b_norm) * 1.5 and r > 100:
        return "ðŸ”´"

    # Green dominant
    if g_norm > max(r_norm, b_norm) * 1.5 and g > 100:
        return "ðŸŸ¢"

    # Blue dominant
    if b_norm > max(r_norm, g_norm) * 1.5 and b > 100:
        return "ðŸ”µ"

    # Yellow (red + green)
    if r > 150 and g > 150 and b < 100:
        return "ðŸŸ¡"

    # Purple/Magenta (red + blue)
    if r > 150 and b > 150 and g < 100:
        return "ðŸŸ£"

    # Orange (more red than green, low blue)
    if r > 200 and g > 100 and g < 200 and b < 100:
        return "ðŸŸ "

    # Brown (dark orange/yellow)
    if 50 < r < 150 and 25 < g < 100 and b < 50:
        return "ðŸŸ¤"

    # Default to gray for mixed/unclear colors
    return "âšª"


def monitor_loop(rgb_control):
    """Main monitoring loop using i3-msg subscribe"""
    log("Monitoring i3 workspaces... (Ctrl+C to exit)")

    # Set initial state
    previous_states, _ = update_leds(rgb_control)

    # Subscribe to i3 events
    process = subprocess.Popen(
        ["i3-msg", "-t", "subscribe", "-m", '["workspace", "window"]'],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )

    try:
        while True:
            line = process.stdout.readline()
            if not line:
                break

            try:
                event = json.loads(line)
                # Check if this is an event that might change workspace state
                if event.get("change") in [
                    "focus",
                    "init",
                    "empty",
                    "urgent",
                    "new",
                    "close",
                    "move",
                ]:
                    previous_states, changed = update_leds(rgb_control, previous_states)
                    if changed and not rgb_control.connected:
                        # Try to reconnect if we lost connection
                        rgb_control.connect()
                        update_leds(rgb_control, {})  # Force full update
            except json.JSONDecodeError:
                continue
            except Exception as e:
                log(f"Error processing event: {e}", always=True)

    except KeyboardInterrupt:
        log("\nâœ“ Stopping monitor...")
    finally:
        process.terminate()


def signal_handler(signum, frame):
    """Handle shutdown signals"""
    raise KeyboardInterrupt


def main():
    """Main entry point"""
    global VERBOSE
    
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="i3 Workspace RGB Monitor for Voyager")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Enable verbose output for debugging")
    args = parser.parse_args()
    
    VERBOSE = args.verbose
    
    # Kill any existing instances of this script
    try:
        # Get current process ID
        current_pid = os.getpid()
        
        # Find all i3-voyager-rgb processes
        result = subprocess.run(
            ["pgrep", "-f", "i3-voyager-rgb"],
            capture_output=True,
            text=True,
            check=False
        )
        
        if result.returncode == 0:
            pids = result.stdout.strip().split('\n')
            for pid_str in pids:
                try:
                    pid = int(pid_str)
                    # Don't kill ourselves
                    if pid != current_pid:
                        os.kill(pid, signal.SIGTERM)
                        log(f"âœ“ Killed existing i3-voyager-rgb process (PID: {pid})", always=True)
                        # Give it a moment to clean up
                        time.sleep(0.5)
                except (ValueError, ProcessLookupError):
                    pass
    except Exception as e:
        # Silently continue if we can't kill old processes
        pass
    
    log("=" * 50)
    log("i3 Workspace â†’ Voyager RGB Monitor (Lite)")
    log("=" * 50)

    # Set up signal handlers
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    # Check dependencies
    try:
        subprocess.run(["i3-msg", "--version"], capture_output=True, check=True)
    except:
        log("âœ— Error: i3-msg not found. Is i3 installed?", always=True)
        return 1

    try:
        # Check for both 'Keymapp' and 'keymapp' (case variations)
        result = subprocess.run(
            ["pgrep", "-fi", "keymapp"], capture_output=True, check=True
        )
        if result.returncode == 0:
            log("âœ“ Keymapp is running")
    except:
        log("âš  Warning: Keymapp doesn't appear to be running", always=True)
        log("  Please start Keymapp for LED control to work", always=True)
        log("")

    # Initialize RGB control
    rgb_control = VoyagerRGBControl()
    if not rgb_control.connect():
        log("\nâœ— Failed to connect to Keymapp", always=True)
        log("  Please ensure:", always=True)
        log("  1. Keymapp is running", always=True)
        log("  2. Your Voyager keyboard is connected", always=True)
        log("  3. You're in the speech-to-text venv (if needed)", always=True)
        return 1

    log("")
    log("LED Mapping:")
    log("  Workspace 1-10 â†’ F1-F10 keys")
    log("\nColor Mappings (from keyboard-led-colours.json):")
    log("")

    # Show color mappings
    for base_state, color_name in STATE_COLOR_MAP.items():
        # Format state display name
        if base_state == "claude_ready":
            state_display = "Claude Ready"
        elif base_state == "claude_busy":
            state_display = "Claude Busy"
        else:
            state_display = base_state.capitalize()

        # Show unfocused version
        unfocused_key = base_state
        unfocused_actual = COLORS[unfocused_key]
        unfocused_circle = get_color_circle(*unfocused_actual)

        # Show focused version
        focused_key = f"{base_state}_focused"
        focused_actual = COLORS[focused_key]
        focused_circle = get_color_circle(*focused_actual)

        state_display = state_display.ljust(12)

        # Print both unfocused and focused versions with color names
        log(
            f"  {unfocused_circle} {state_display} unfocused: {color_name}_dim â†’ RGB{unfocused_actual}"
        )
        log(
            f"  {focused_circle} {state_display} focused:   {color_name}_bright â†’ RGB{focused_actual}"
        )

    log("")

    try:
        monitor_loop(rgb_control)
    finally:
        rgb_control.cleanup()
        log("âœ“ LEDs cleared")

    return 0


if __name__ == "__main__":
    sys.exit(main())
