#!/bin/bash
#
# Long-running command wrapper that updates workspace status
# Usage:
#   long <command> [args...]  - Run command with status tracking
#   long --clear              - Clear task status for current workspace
#
# Sets workspace status to:
#   - task-running while command executes
#   - task-complete if command succeeds (exit 0)
#   - task-failed if command fails (non-zero exit)

# Exit if TERMINAL_WORKSPACE is not set
if [ -z "$TERMINAL_WORKSPACE" ]; then
    echo "Error: TERMINAL_WORKSPACE not set. This command must be run from within i3." >&2
    exit 1
fi

# Status file location
STATUS_FILE=~/.config/i3/workspace-status.json

# No longer need these functions - using set-workspace-status instead

# Handle --clear flag
if [ "$1" = "--clear" ]; then
    # Clear all task-related states
    set-workspace-status task-clear
    echo "Cleared task status for workspace $TERMINAL_WORKSPACE"
    exit 0
fi

# Check if command was provided
if [ $# -eq 0 ]; then
    echo "Usage: long <command> [args...]" >&2
    echo "       long --clear" >&2
    exit 1
fi

# Store the command for display
COMMAND="$*"

# Get start time
START_TIME=$(date +%s)
START_DATE=$(date '+%Y-%m-%d %H:%M:%S')

# Set status to task-running (automatically clears other task states)
set-workspace-status task-running

# Show what we're running with timing info
echo "üèÉ Running: $COMMAND"
echo "üìç Workspace: $TERMINAL_WORKSPACE"
echo "üïê Started: $START_DATE"
echo ""

# Set environment variable to indicate we're running under long
export LONG_WRAPPED=1

# Run the command, preserving all arguments and output
"$@"
EXIT_CODE=$?

# Get end time and calculate duration
END_TIME=$(date +%s)
END_DATE=$(date '+%Y-%m-%d %H:%M:%S')
DURATION=$((END_TIME - START_TIME))

# Format duration nicely
if [ $DURATION -lt 60 ]; then
    DURATION_STR="${DURATION}s"
elif [ $DURATION -lt 3600 ]; then
    MINUTES=$((DURATION / 60))
    SECONDS=$((DURATION % 60))
    DURATION_STR="${MINUTES}m ${SECONDS}s"
else
    HOURS=$((DURATION / 3600))
    MINUTES=$(((DURATION % 3600) / 60))
    SECONDS=$((DURATION % 60))
    DURATION_STR="${HOURS}h ${MINUTES}m ${SECONDS}s"
fi

# Update status based on exit code
if [ $EXIT_CODE -eq 0 ]; then
    set-workspace-status task-succeeded
    echo ""
    echo "‚úÖ Command completed successfully (exit code: 0)"
    echo "üïë Finished: $END_DATE"
    echo "‚è±Ô∏è  Duration: $DURATION_STR"

    # Send notification if available (include duration)
    if command -v notify >/dev/null 2>&1; then
        notify "‚úÖ Task complete on workspace $TERMINAL_WORKSPACE after $DURATION_STR: $COMMAND"
    fi
else
    set-workspace-status task-failed
    echo ""
    echo "‚ùå Command failed (exit code: $EXIT_CODE)"
    echo "üïë Finished: $END_DATE"
    echo "‚è±Ô∏è  Duration: $DURATION_STR"

    # Send notification if available (include duration)
    if command -v notify >/dev/null 2>&1; then
        notify "‚ùå Task failed on workspace $TERMINAL_WORKSPACE (exit $EXIT_CODE) after $DURATION_STR: $COMMAND"
    fi
fi

# Return the same exit code as the command
exit $EXIT_CODE
