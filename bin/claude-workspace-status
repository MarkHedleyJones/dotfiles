#!/bin/bash
#
# Update workspace status based on TERMINAL_WORKSPACE environment variable
# Usage: claude-workspace-status [ready|busy|clear]
#
# This script is designed to be called from Claude Code hooks to update
# the workspace status that the i3-voyager-rgb script uses for LED colors.
# States: ai-ready, ai-busy, or clear (to remove AI state)

# Exit if TERMINAL_WORKSPACE is not set
if [ -z "$TERMINAL_WORKSPACE" ]; then
    exit 0
fi

# Handle status mapping
# Accept multiple statuses: "complete" = "ai-ready ai-complete"
# "ai-exited" or "exited" will clear all AI states
STATUSES=""
if [ $# -eq 0 ]; then
    STATUSES="ai-ready"  # Default to ready
elif [ "$1" = "clear" ] || [ "$1" = "exited" ] || [ "$1" = "ai-exited" ] || [ -z "$1" ]; then
    STATUSES=""  # Clear all AI states
else
    # Process all arguments and map them
    for arg in "$@"; do
        case "$arg" in
            ready) STATUSES="$STATUSES ai-ready" ;;
            busy) STATUSES="$STATUSES ai-busy" ;;
            complete) STATUSES="$STATUSES ai-ready ai-complete" ;;  # complete sets both
            *) STATUSES="$STATUSES $arg" ;;  # Pass through unknown states
        esac
    done
fi
# Trim leading/trailing spaces
STATUSES=$(echo "$STATUSES" | xargs)

# Ensure the directory exists
mkdir -p ~/.config/i3

# Status file location
STATUS_FILE=~/.config/i3/workspace-status.json

# Create the status file with all 10 workspaces if it doesn't exist
# Use arrays with "empty" as the default state
if [ ! -f "$STATUS_FILE" ]; then
    echo '{
  "1": ["empty"],
  "2": ["empty"],
  "3": ["empty"],
  "4": ["empty"],
  "5": ["empty"],
  "6": ["empty"],
  "7": ["empty"],
  "8": ["empty"],
  "9": ["empty"],
  "10": ["empty"]
}' > "$STATUS_FILE"
fi

# Update the status for the current workspace
# Using a temp file to avoid corruption if interrupted
TEMP_FILE="/tmp/claude-status-$$"

# Handle adding or removing AI status
if [ -z "$STATUSES" ]; then
    # Clear AI status - remove ai-ready, ai-busy, and ai-complete from array
    jq --arg ws "$TERMINAL_WORKSPACE" '
      # Ensure all 10 workspaces exist as arrays
      . as $current |
      (["1","2","3","4","5","6","7","8","9","10"] |
       map({key: ., value: (
         if $current[.] == null then ["empty"]
         elif $current[.] | type == "array" then $current[.]
         else [$current[.]]
         end
       )}) |
       from_entries) |
      # Remove AI states from workspace array
      .[$ws] = (
        (.[$ws] // ["occupied"]) as $states |
        [$states[] | select(. != "ai-ready" and . != "ai-busy" and . != "ai-complete" and . != "claude-ready" and . != "claude-busy")] as $new_states |
        if ($new_states | length) == 0 then ["occupied"]
        else $new_states
        end
      ) |
      # Sort by numeric key
      to_entries | sort_by(.key | tonumber) | from_entries
    ' "$STATUS_FILE" > "$TEMP_FILE" && mv "$TEMP_FILE" "$STATUS_FILE"
else
    # Add AI statuses to array
    # First remove any existing AI states, then add the new ones
    # Convert space-separated statuses to JSON array
    STATUS_ARRAY=$(echo "$STATUSES" | tr ' ' '\n' | jq -R . | jq -s .)

    jq --arg ws "$TERMINAL_WORKSPACE" --argjson statuses "$STATUS_ARRAY" '
      # Ensure all 10 workspaces exist as arrays
      . as $current |
      (["1","2","3","4","5","6","7","8","9","10"] |
       map({key: ., value: (
         if $current[.] == null then ["empty"]
         elif $current[.] | type == "array" then $current[.]
         else [$current[.]]
         end
       )}) |
       from_entries) |
      # Remove old AI states and add new ones
      .[$ws] = (
        (.[$ws] // ["occupied"]) as $states |
        # Remove any existing AI states
        [$states[] | select(. != "ai-ready" and . != "ai-busy" and . != "ai-complete" and . != "claude-ready" and . != "claude-busy")] as $clean_states |
        # Add all new statuses
        ($clean_states + $statuses | unique)
      ) |
      # Sort by numeric key
      to_entries | sort_by(.key | tonumber) | from_entries
    ' "$STATUS_FILE" > "$TEMP_FILE" && mv "$TEMP_FILE" "$STATUS_FILE"
fi

# Return success/failure based on the operation
if [ $? -eq 0 ]; then
    exit 0
else
    exit 1
fi
