#!/bin/bash
#
# set-workspace-status - Central workspace status management
#
# Usage: set-workspace-status [workspace] <state>
#   workspace: 1-10 (optional, defaults to $TERMINAL_WORKSPACE)
#   state: State to set (see below)
#
# State Management Rules:
#   - ai-* states are mutually exclusive (except ai-complete adds to ai-ready)
#   - task-* states are mutually exclusive
#   - focused/unfocused are special toggle states
#   - urgent/occupied/empty are base states
#
# Examples:
#   set-workspace-status ai-ready       # Set AI ready on current workspace
#   set-workspace-status 5 task-running # Set task running on workspace 5
#   set-workspace-status focused        # Add focused to current workspace
#   set-workspace-status unfocused      # Remove focused from current workspace

# Parse arguments - check if first arg is a workspace number
WORKSPACE=""
STATE=""
if [[ "$1" =~ ^[1-9]$|^10$ ]]; then
	WORKSPACE="$1"
	STATE="$2"
else
	# Try to detect workspace using get-workspace-id
	if command -v get-workspace-id >/dev/null 2>&1; then
		WORKSPACE=$(get-workspace-id)
	else
		# Fallback to legacy TERMINAL_WORKSPACE if get-workspace-id not available
		WORKSPACE="$TERMINAL_WORKSPACE"
	fi
	STATE="$1"
fi

# Validate workspace
if [ -z "$WORKSPACE" ]; then
	echo "Error: Could not determine workspace (no window found in process tree)" >&2
	exit 1
fi

if ! [[ "$WORKSPACE" =~ ^[1-9]$|^10$ ]]; then
	echo "Error: Invalid workspace: $WORKSPACE (must be 1-10)" >&2
	exit 1
fi

# Validate state provided
if [ -z "$STATE" ]; then
	echo "Error: No state specified" >&2
	echo "Usage: set-workspace-status [workspace] <state>" >&2
	exit 1
fi

# Status file location
STATUS_FILE=~/.config/i3/workspace-status.json

# Ensure directory exists
mkdir -p ~/.config/i3

# Create file with empty workspaces if it doesn't exist
if [ ! -f "$STATUS_FILE" ]; then
	echo '{
  "1": ["empty"],
  "2": ["empty"],
  "3": ["empty"],
  "4": ["empty"],
  "5": ["empty"],
  "6": ["empty"],
  "7": ["empty"],
  "8": ["empty"],
  "9": ["empty"],
  "10": ["empty"]
}' >"$STATUS_FILE"
fi

# Temp file for atomic updates
TEMP_FILE="/tmp/workspace-status-$$"

# Process the state and update the JSON file
case "$STATE" in
# AI states (mutually exclusive within subsystem)
ai-ready | ready)
	jq --arg ws "$WORKSPACE" '
          .[$ws] = ((.[$ws] // []) | map(select(. | startswith("ai-") | not)) + ["ai-ready"] | unique)
        ' "$STATUS_FILE" >"$TEMP_FILE"
	;;

ai-busy | busy)
	jq --arg ws "$WORKSPACE" '
          .[$ws] = ((.[$ws] // []) | map(select(. | startswith("ai-") | not)) + ["ai-busy"] | unique)
        ' "$STATUS_FILE" >"$TEMP_FILE"
	;;

ai-complete | complete)
	# Special case: adds both ai-ready and ai-complete
	# But only add ai-complete if workspace is not focused
	jq --arg ws "$WORKSPACE" '
          .[$ws] as $states |
          if ($states // [] | index("focused")) then
            .[$ws] = (($states // []) | map(select(. | startswith("ai-") | not)) + ["ai-ready"] | unique)
          else
            .[$ws] = (($states // []) | map(select(. | startswith("ai-") | not)) + ["ai-ready", "ai-complete"] | unique)
          end
        ' "$STATUS_FILE" >"$TEMP_FILE"
	# Send TTS notification if available
	if command -v tts >/dev/null 2>&1; then
		tts "AI complete on workspace $WORKSPACE" &
	fi
	;;

ai-exited | exited)
	# Remove all AI states
	jq --arg ws "$WORKSPACE" '
          .[$ws] = ((.[$ws] // []) | map(select(. | startswith("ai-") | not)) | if length == 0 then ["occupied"] else . end)
        ' "$STATUS_FILE" >"$TEMP_FILE"
	;;

# Task states (mutually exclusive within subsystem)
task-running)
	jq --arg ws "$WORKSPACE" '
          .[$ws] = ((.[$ws] // []) | map(select(. | startswith("task-") | not)) + ["task-running"] | unique)
        ' "$STATUS_FILE" >"$TEMP_FILE"
	;;

task-succeeded)
	# Only add task-succeeded if workspace is not focused
	jq --arg ws "$WORKSPACE" '
          .[$ws] as $states |
          if ($states // [] | index("focused")) then
            .[$ws] = (($states // []) | map(select(. | startswith("task-") | not)))
          else
            .[$ws] = (($states // []) | map(select(. | startswith("task-") | not)) + ["task-succeeded"] | unique)
          end
        ' "$STATUS_FILE" >"$TEMP_FILE"
	# Send TTS notification if available
	if command -v tts >/dev/null 2>&1; then
		tts "Task succeeded on workspace $WORKSPACE" &
	fi
	;;

task-failed)
	jq --arg ws "$WORKSPACE" '
          .[$ws] = ((.[$ws] // []) | map(select(. | startswith("task-") | not)) + ["task-failed"] | unique)
        ' "$STATUS_FILE" >"$TEMP_FILE"
	# Send TTS notification if available
	if command -v tts >/dev/null 2>&1; then
		tts "Task failed on workspace $WORKSPACE" &
	fi
	;;

task-clear)
	# Remove all task states
	jq --arg ws "$WORKSPACE" '
          .[$ws] = ((.[$ws] // []) | map(select(. | startswith("task-") | not)) | if length == 0 then ["occupied"] else . end)
        ' "$STATUS_FILE" >"$TEMP_FILE"
	;;

# Focus states (toggle)
focused)
	# Add focused state, remove ai-complete, task-succeeded, and urgent (notification states)
	jq --arg ws "$WORKSPACE" '
          .[$ws] = ((.[$ws] // []) | map(select(. != "ai-complete" and . != "task-succeeded" and . != "urgent")) + ["focused"] | unique)
        ' "$STATUS_FILE" >"$TEMP_FILE"
	;;

unfocused)
	# Remove focused state
	jq --arg ws "$WORKSPACE" '
          .[$ws] = ((.[$ws] // []) | map(select(. != "focused")) | if length == 0 then ["occupied"] else . end)
        ' "$STATUS_FILE" >"$TEMP_FILE"
	;;

# Base states
urgent)
	jq --arg ws "$WORKSPACE" '
          .[$ws] = ((.[$ws] // []) + ["urgent"] | unique)
        ' "$STATUS_FILE" >"$TEMP_FILE"
	# Send TTS notification if available
	if command -v tts >/dev/null 2>&1; then
		tts "Urgent on workspace $WORKSPACE" &
	fi
	;;

occupied)
	# Remove empty if present, add occupied
	jq --arg ws "$WORKSPACE" '
          .[$ws] = ((.[$ws] // []) | map(select(. != "empty")) + ["occupied"] | unique)
        ' "$STATUS_FILE" >"$TEMP_FILE"
	;;

empty)
	# Clear all states, set to empty
	jq --arg ws "$WORKSPACE" '
          .[$ws] = ["empty"]
        ' "$STATUS_FILE" >"$TEMP_FILE"
	;;

clear)
	# Clear all states to occupied
	jq --arg ws "$WORKSPACE" '
          .[$ws] = ["occupied"]
        ' "$STATUS_FILE" >"$TEMP_FILE"
	;;

*)
	echo "Error: Unknown state: $STATE" >&2
	echo "Valid states:" >&2
	echo "  AI: ai-ready, ai-busy, ai-complete, ai-exited" >&2
	echo "  Task: task-running, task-succeeded, task-failed, task-clear" >&2
	echo "  Focus: focused, unfocused" >&2
	echo "  Base: urgent, occupied, empty, clear" >&2
	echo "  Shortcuts: ready, busy, complete, exited" >&2
	exit 1
	;;
esac

# Move temp file to actual file (atomic update)
if [ -f "$TEMP_FILE" ]; then
	mv "$TEMP_FILE" "$STATUS_FILE"
	exit 0
else
	echo "Error: Failed to update workspace status" >&2
	exit 1
fi
